## Sennaar Roadmap

**Registry Storage Format:** Two forms
- **DSL format:** Human-readable and writable
  - Also, it can be parsed and generated by Rust implementation.
- **JSON / XML format:** Machine-readable.
  - For languages that cannot parse and generate the DSL format, they can consume the JSON / XML format converted from the DSL format by the Rust implementation.
- Freely convertible between the two formats.

**Extracting the Registry:** Four approaches
- **`rossetta`:** Use `libclang`, the industry-standard solution, offering the highest versatility. However, it has high environmental requirements (e.g., `libclang` may fail if it cannot find the necessary header files for the target library). The generated registry is bound to the host platform (e.g., only one branch of an `#ifdef` can be taken), and it loses metadata. Suitable for simpler scenarios. Can be modeled after the usage of `rust-bindgen`.
  - *We are considering a "metadata merger": Run `rossetta` on multiple platforms, generate the metadata for each platform, and then merge the metadata into a single registry. This way, we can preserve the metadata while using `libclang` for parsing.*
- **`panspace`:** A solution that has been progressively matured in the vulkan4j project. It first uses `hparse` for line-directed guidance, followed by `cdecl` for precise parsing. The advantage of this system is that it does not require the complete environment needed to compile the target library, and it can preserve metadata present as macros in the source code (e.g., `NULLABLE`, `NOTNULL`, `_In_`, `_Opt_`). It can also retain features from multiple platforms. The drawback is that the rules required by the `hparse` module must be configured manually.
- **Converting from existing registries:** Khronos APIs (Vulkan, OpenGL, OpenCL, OpenXR, ...) have XML registries (but not very unified); WebGPU has a YML IDL registry. The conversion is straightforward. Also, we can "steal" metadata from existing projects like LWJGL (uses a Kotlin DSL).
- **Manual or semi-manual maintenance:** Generate once, then manually update as needed.

**Handling Platform-Specific Features:** Two methods
- Automatic handling via **`ARCH - OS - ENDIAN - LIBC`** quadruple, with exhaustive checks.
- **Manual tagging** — extra **`- [CUSTOM]`** property, handled manually by the backend (with provided verification methods).

**Phase 1 Backends:** A Three-Pronged Approach
- **Core Principle — "Pick the low-hanging fruit":** Prioritize languages that lack official or semi-official CFFI tools.
  (JNI and Python have SWIG, Rust has `rust-bindgen`; these are difficult markets to penetrate).
- **FFM backend:** Java + FFM (there are some existing work in the `vulkan4j` project). *OpenJDK devs already provides `jextract` but it generates things in very brutal way. Using the bindings generated by `jextract` is outlawed by the 'cruel and unusual punishment' clause in Article 5 of the Universal Declaration of Human Rights.*
- **Moonbit backend:** Target Moonbit, where CFFI support is still very premature (native / wasm / wasm-gc).
- **Racket backend:** Racket (prioritizing the use of Racket's `read` or Rhombus, as a technical showcase). *optional, do this when we have spare time.*
